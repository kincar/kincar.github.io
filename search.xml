<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue中的路由</title>
      <link href="/2022/01/08/vue%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
      <url>/2022/01/08/vue%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="一、vue-router的理解"><a href="#一、vue-router的理解" class="headerlink" title="一、vue-router的理解"></a>一、vue-router的理解</h3><p>vue的一个插件库，专门用来实现<code>SPA应用</code></p><h3 id="二、SPA应用"><a href="#二、SPA应用" class="headerlink" title="二、SPA应用"></a>二、SPA应用</h3><ol><li><p>单页Web应用（single page web application，SPA）；</p></li><li><p>整个应用<code>只有一个完整的页面</code>；</p></li><li><p>点击页面中的导航链接<code>不会刷新</code>页面，只会做页面的<code>局部刷新</code>；</p></li><li><p>数据需要通过Ajax请求获取。</p></li></ol><h3 id="三、路由的理解"><a href="#三、路由的理解" class="headerlink" title="三、路由的理解"></a>三、路由的理解</h3><ol><li><p>什么是路由？</p><p> （1）一个路由（route）就是一组映射关系（key-value），多个路由需要路由器（router）进行管理。</p><p> （2）key为路径，value可能是function或<code>component</code></p></li><li><p>路由分类</p><ul><li><p>后端路由：</p><ul><li><p>理解：value是function，用于处理客户端提交的请求。</p></li><li><p>工作过程：服务器收到一个请求时，根据<code>请求路径</code>找到匹配的<code>函数</code>来处理请求，返回响应数据。</p></li></ul></li><li><p><strong>前端路由：</strong></p><ul><li><p>理解：value是component组件，用于展示页面内容。</p></li><li><p>工作过程：当浏览器的路径改变时，对应的组件就会显示。</p></li></ul></li></ul></li></ol><h3 id="四、基本使用"><a href="#四、基本使用" class="headerlink" title="四、基本使用"></a>四、基本使用</h3><ol><li><p>安装vue-router，命令：npm i –save vue-router</p></li><li><p>应用插件：Vue.use(VueRouter)</p></li><li><p>编写router配置项：</p></li></ol><pre class=" language-bash"><code class="language-bash">//引入VueRouter<span class="token function">import</span> VueRouter from <span class="token string">'vue-router'</span>//引入路由组件<span class="token function">import</span> About from <span class="token string">'../components/About'</span><span class="token function">import</span> Home from <span class="token string">'../components/Home'</span>//创建router实例对象，去管理一组一组的路由规则const router <span class="token operator">=</span> new VueRouter<span class="token punctuation">(</span><span class="token punctuation">{</span>    routes:<span class="token punctuation">[</span>        <span class="token punctuation">{</span>            path: <span class="token string">'/about'</span>,            component: About        <span class="token punctuation">}</span>,        <span class="token punctuation">{</span>            path: <span class="token string">'/home'</span>,            component: Home        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>//暴露router<span class="token function">export</span> default router</code></pre><ol start="4"><li>实现切换（active-class可配置高亮样式）</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>router-link active-class<span class="token operator">=</span><span class="token string">"active"</span> to<span class="token operator">=</span><span class="token string">"/about"</span><span class="token operator">></span>About<span class="token operator">&lt;</span>/router-link<span class="token operator">></span></code></pre><ol start="5"><li>指定展示位置</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>router-view<span class="token operator">></span><span class="token operator">&lt;</span>/router-view<span class="token operator">></span></code></pre><h3 id="五、几个注意点"><a href="#五、几个注意点" class="headerlink" title="五、几个注意点"></a>五、几个注意点</h3><ol><li><p>路由组件通常存放在<code>pages</code>文件夹，一般组件通常放在<code>components</code>文件夹。</p></li><li><p>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p></li><li><p>每个组件都有自己的$route属性，里面存储着自己的路由信息。</p></li><li><p>整个应用只有一个router，可以通过组件的$router属性获取到。</p></li></ol><h3 id="六、多级路由（嵌套路由）"><a href="#六、多级路由（嵌套路由）" class="headerlink" title="六、多级路由（嵌套路由）"></a>六、多级路由（嵌套路由）</h3><ol><li>配置路由规则，使用children配置项：</li></ol><pre class=" language-bash"><code class="language-bash">routes:<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        path: <span class="token string">'/about'</span>,        component: About,    <span class="token punctuation">}</span>,    <span class="token punctuation">{</span>        path: <span class="token string">'/home'</span>,        component: Home,        children: <span class="token punctuation">[</span> //通过children配置子级路由            <span class="token punctuation">{</span>                path: <span class="token string">'news'</span>, //此处一定不要写：/news                component: News            <span class="token punctuation">}</span>,            <span class="token punctuation">{</span>                path: <span class="token string">'message'</span>, //此处一定不要写：/message                component: Message            <span class="token punctuation">}</span>        <span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><ol start="2"><li>跳转（要写完整路径）：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>router-link to<span class="token operator">=</span><span class="token string">"/home/news"</span><span class="token operator">></span>News<span class="token operator">&lt;</span>/router-link<span class="token operator">></span></code></pre><h3 id="七、路由的query参数"><a href="#七、路由的query参数" class="headerlink" title="七、路由的query参数"></a>七、路由的query参数</h3><ol><li>传递参数</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 跳转并携带query参数，to的字符串写法 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link :to<span class="token operator">=</span><span class="token string">"/home/message/detail?id=666&amp;title=你好"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 跳转并携带query参数，to的对象写法 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link    :to<span class="token operator">=</span> <span class="token string">"{        path: '/home/message/detail',        query: {            id: 666,            title: '你好'        }    }"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span></code></pre><ol start="2"><li>接收参数：</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token variable">$route</span>.query.id<span class="token variable">$route</span>.query.title</code></pre><h3 id="八、命名路由"><a href="#八、命名路由" class="headerlink" title="八、命名路由"></a>八、命名路由</h3><ol><li><p>作用：可以<code>简化</code>路由的跳转</p></li><li><p>如何使用？</p><p> （1）给路由命名：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>    path: <span class="token string">'/demo'</span>,    component: Demo,    children: <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            path: <span class="token string">'test'</span>,            component: Test,            children: <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    name: <span class="token string">'hello'</span>, //给路由命名                    path: <span class="token string">'welcome'</span>,                    component: Hello                <span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p> （2）简化跳转：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 简化前，需要写完整的路径 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link to<span class="token operator">=</span><span class="token string">"/demo/test/welcom"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 简化后，直接通过名字跳转 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link :to<span class="token operator">=</span><span class="token string">"{name: hello}"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 简化写法配合传递参数 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link     :to<span class="token operator">=</span><span class="token string">"{        name: 'hello',        query: {            id: 666,            title: '你好'        }    }"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span></code></pre></li></ol><h3 id="九、路由的params参数"><a href="#九、路由的params参数" class="headerlink" title="九、路由的params参数"></a>九、路由的params参数</h3><p>1.配置路由，声明接收params参数</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>    path: <span class="token string">'/home'</span>,    component: Home,    children: <span class="token punctuation">[</span>        <span class="token punctuation">{</span>            path: <span class="token string">'news'</span>,            component: News        <span class="token punctuation">}</span>,        <span class="token punctuation">{</span>            path: <span class="token string">'message'</span>,            component: Message,            children: <span class="token punctuation">[</span>                <span class="token punctuation">{</span>                    name: <span class="token string">'xiangqing'</span>,                    path: <span class="token string">'detail/:id/:title'</span>, //使用占位符声明接收params参数                    component: Detail                <span class="token punctuation">}</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><ol start="2"><li>传递参数</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span><span class="token operator">!</span>-- 跳转并携带params参数，to的字符串写法 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link :to<span class="token operator">=</span><span class="token string">"/home/message/detail/666/你好"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">!</span>-- 跳转并携带params参数，to的对象写法 --<span class="token operator">></span><span class="token operator">&lt;</span>router-link    :to<span class="token operator">=</span><span class="token string">"{        name: 'xiangqing', //这里必须使用name，不能使用path！！        params: {            id: 666,            title: '你好'        }    }"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/router-link<span class="token operator">></span></code></pre><blockquote><p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！！</p></blockquote><ol start="3"><li>接收参数</li></ol><pre class=" language-bash"><code class="language-bash"><span class="token variable">$route</span>.params.id<span class="token variable">$route</span>.params.title</code></pre><h3 id="十、路由的props配置"><a href="#十、路由的props配置" class="headerlink" title="十、路由的props配置"></a>十、路由的props配置</h3><p>作用：让路由组件更方便的收到参数</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">{</span>    name: <span class="token string">'xiangqing'</span>,    path: <span class="token string">'detail/:id'</span>,    component: Detail,    //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件    // props:<span class="token punctuation">{</span>a:900<span class="token punctuation">}</span>    //第二种写法：props为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件    // props: <span class="token boolean">true</span>    //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件<span class="token punctuation">(</span>更灵活<span class="token punctuation">)</span>    props<span class="token punctuation">(</span>route<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">{</span>            id: route.query.id,            title:route.query.title        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="十一、的replace属性"><a href="#十一、的replace属性" class="headerlink" title="十一、的replace属性"></a>十一、<router-link>的replace属性</h3><ol><li><p>作用：控制路由跳转时浏览器历史记录的模式</p></li><li><p>浏览器的历史记录有两种写入方式：分别为push和replace，push是<code>追加</code>历史记录，replace是<code>替换</code>历史记录。路由跳转时<code>默认为push</code></p></li><li><p>如何开启replace模式：&lt;router-link replace ……&gt;News</router-link></p></li></ol><h3 id="十二、编程式路由导航"><a href="#十二、编程式路由导航" class="headerlink" title="十二、编程式路由导航"></a>十二、编程式路由导航</h3><ol><li><p>作用：不借助<router-link>实现路由跳转，让路由跳转更加灵活</p></li><li><p>具体代码：</p></li></ol><pre class=" language-bash"><code class="language-bash">//<span class="token variable">$router</span>的两个APIthis.<span class="token variable">$router</span>.push<span class="token punctuation">(</span><span class="token punctuation">{</span> //相当于点击路由链接（可以返回当前路由界面）    name: <span class="token string">'xiangqing'</span>,    params: <span class="token punctuation">{</span>        id: xxx,        title: xxx    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>this.<span class="token variable">$router</span>.replace<span class="token punctuation">(</span><span class="token punctuation">{</span> //用新路由替换当前路由（不可以返回到当前路由界面）    name: <span class="token string">'xiangqing'</span>,    params:<span class="token punctuation">{</span>        id: xxx,        title: xxx    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>this.<span class="token variable">$router</span>.forward<span class="token punctuation">(</span><span class="token punctuation">)</span> //前进 ；请求（返回）下一个记录路由this.<span class="token variable">$router</span>.back<span class="token punctuation">(</span><span class="token punctuation">)</span> //后退；请求（返回）上一个记录路由this.<span class="token variable">$router</span>.go<span class="token punctuation">(</span><span class="token punctuation">)</span> //可前进也可后退（传1或-1）</code></pre><h3 id="十三、缓存路由组件"><a href="#十三、缓存路由组件" class="headerlink" title="十三、缓存路由组件"></a>十三、缓存路由组件</h3><ol><li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p></li><li><p>具体代码：</p></li></ol><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>keep-alive inclue<span class="token operator">=</span><span class="token string">"News"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>router-view<span class="token operator">></span><span class="token operator">&lt;</span>/router-view<span class="token operator">></span><span class="token operator">&lt;</span>/keep-alive<span class="token operator">></span></code></pre><h3 id="十四、两个新的生命周期钩子"><a href="#十四、两个新的生命周期钩子" class="headerlink" title="十四、两个新的生命周期钩子"></a>十四、两个新的生命周期钩子</h3><ol><li><p>作用：路由组件所<code>独有</code>的两个钩子，用于捕获路由组件的激活状态。</p></li><li><p>具体名字：<br> activated路由组件被激活时触发。<br> deactivated路由组件失活时触发。</p></li></ol><h3 id="十五、路由守卫"><a href="#十五、路由守卫" class="headerlink" title="十五、路由守卫"></a>十五、路由守卫</h3><ol><li><p>作用：对路由及进行权限控制</p></li><li><p>分类： 全局守卫、独享守卫、组件内守卫</p><p> （1）全局守卫</p><pre class=" language-bash"><code class="language-bash">//全局前置守卫：初始化时执行，每次路由切换前执行 router.beforeEach<span class="token punctuation">((</span>to,from,next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   console.log<span class="token punctuation">(</span><span class="token string">'before'</span>, to, from<span class="token punctuation">)</span>   if<span class="token punctuation">(</span>to.meta.isAuth<span class="token punctuation">)</span><span class="token punctuation">{</span> //判断当前路由是否需要进行权限控制       if<span class="token punctuation">(</span>localStorage.getItem<span class="token punctuation">(</span><span class="token string">'school'</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'atguigu'</span><span class="token punctuation">)</span><span class="token punctuation">{</span> //权限控制的具体规则           next<span class="token punctuation">(</span><span class="token punctuation">)</span> //放行       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           alert<span class="token punctuation">(</span><span class="token string">'暂无权限查看'</span><span class="token punctuation">)</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       next<span class="token punctuation">(</span><span class="token punctuation">)</span> //放行   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> //全局后置守卫：初始化时执行、每次路由切换后执行 router.afterEach<span class="token punctuation">((</span>to,from<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   console.log<span class="token punctuation">(</span><span class="token string">'afterEach'</span>, to, from<span class="token punctuation">)</span>   if<span class="token punctuation">(</span>to.meta.title<span class="token punctuation">)</span><span class="token punctuation">{</span>       document.title <span class="token operator">=</span> to.meta.title //修改网页的title   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>       document.title <span class="token operator">=</span> <span class="token string">'vue_text'</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> （2）独享守卫</p><pre class=" language-bash"><code class="language-bash">beforeEnter<span class="token punctuation">(</span>to, from, next<span class="token punctuation">)</span><span class="token punctuation">{</span>    console.log<span class="token punctuation">(</span><span class="token string">'beforeEnter'</span>, to, from<span class="token punctuation">)</span>    if<span class="token punctuation">(</span>to.meta.isAuth<span class="token punctuation">)</span><span class="token punctuation">{</span> //判断当前路由是否需要权限控制        if<span class="token punctuation">(</span>localStorage.getItem<span class="token punctuation">(</span><span class="token string">'school'</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">'atguigu'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            next<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            alert<span class="token punctuation">(</span><span class="token string">'暂无权限查看'</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        next<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> （3）组件内守卫：</p><pre class=" language-bash"><code class="language-bash">//进入守卫：通过路由规则，进入该组件时被调用beforeRouterEnter<span class="token punctuation">(</span>to, from, next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>//离开守卫：通过路由规则，离开组件时被调用beforeRouterLeave<span class="token punctuation">(</span>to, from, next<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="十六、路由器的两种工作模式"><a href="#十六、路由器的两种工作模式" class="headerlink" title="十六、路由器的两种工作模式"></a>十六、路由器的两种工作模式</h3><ol><li><p>对于一个url来说，什么是hash值？ ———— #及其后面的内容就是hash值。</p></li><li><p>hash值不会包含在HTTP请求中，即：hash值不会带给服务器。</p></li><li><p>hash模式(默认模式)：</p><ul><li><p>地址中永远带着#号，不美观。</p></li><li><p>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</p></li><li><p>兼容性好</p></li></ul></li><li><p>history模式(mode: ‘history’)：</p><ul><li><p>地址干净，美观。</p></li><li><p>兼容性和hash模式相比略差。</p></li><li><p>应用部署上线时需要后端人员支持，解决刷新页面服务端404问题。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 路由 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你会用ES6，那倒是用啊</title>
      <link href="/2022/01/06/es6%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/01/06/es6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="你会用ES6，那倒是用啊"><a href="#你会用ES6，那倒是用啊" class="headerlink" title="你会用ES6，那倒是用啊"></a>你会用ES6，那倒是用啊</h1><h2 id="一、关于取值"><a href="#一、关于取值" class="headerlink" title="一、关于取值"></a>一、关于取值</h2><p>取值在程序中非常常见，比如从对象<code>obj</code>中取值</p><pre class=" language-bash"><code class="language-bash">const obj <span class="token operator">=</span> <span class="token punctuation">{</span>    a: 1,    b: 2,    c: 3,    d: 4,    e: 5<span class="token punctuation">}</span></code></pre><p><strong>吐槽：</strong></p><pre class=" language-bash"><code class="language-bash">const a <span class="token operator">=</span> obj.a<span class="token punctuation">;</span>const b <span class="token operator">=</span> obj.b<span class="token punctuation">;</span>const c <span class="token operator">=</span> obj.c<span class="token punctuation">;</span>const d <span class="token operator">=</span> obj.d<span class="token punctuation">;</span>const e <span class="token operator">=</span> obj.e<span class="token punctuation">;</span>或者const f <span class="token operator">=</span> obj.a + obj.d<span class="token punctuation">;</span>const g <span class="token operator">=</span> obj.c + obj.e</code></pre><p>吐槽：“不会用ES6的解构赋值来取值吗？5行代码用1行代码搞定不香吗？直接用对象名+属性名去取值，要是对象名短还好，很长呢？搞得代码中到处都是这个对象名！”</p><p><strong>改进：</strong></p><pre class=" language-bash"><code class="language-bash">const <span class="token punctuation">{</span>a,b,c,d,e<span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>const f <span class="token operator">=</span> a + d<span class="token punctuation">;</span>const g <span class="token operator">=</span> c + e<span class="token punctuation">;</span></code></pre><p><strong>反驳</strong></p><p>不是不用ES6的结构赋值，而是服务端返回的数据对象中的属性名不是我想要的，这样取值，不是还得重新创建个遍历赋值</p><p><strong>吐槽</strong></p><p>看来你对ES6的解构赋值掌握的还是不够彻底。如果想创建的变量名和对象的属性名不一致，可以这么写：</p><pre class=" language-bash"><code class="language-bash">const <span class="token punctuation">{</span>a: a1<span class="token punctuation">}</span> <span class="token operator">=</span> objconsole.log<span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> //1</code></pre><p><strong>补充</strong><br>ES6的结构赋值虽然好用。但是要注意结构的对象不能为<code>undefined、null</code>。否则会报错，故要给被解构的对象一个默认值。</p><pre class=" language-bash"><code class="language-bash">const <span class="token punctuation">{</span>a,b,c,d,e<span class="token punctuation">}</span> <span class="token operator">=</span> obj <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="二、关于合并数据"><a href="#二、关于合并数据" class="headerlink" title="二、关于合并数据"></a>二、关于合并数据</h2><p>比如合并两个数组，合并两个对象。</p><pre class=" language-bash"><code class="language-bash">const a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token punctuation">;</span>const b <span class="token operator">=</span> <span class="token punctuation">[</span>1,5,6<span class="token punctuation">]</span><span class="token punctuation">;</span>const c <span class="token operator">=</span> a.concat<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token punctuation">[</span>1,2,3,1,5,6<span class="token punctuation">]</span>const obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>    a: 1,<span class="token punctuation">}</span>const obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>    b: 1,<span class="token punctuation">}</span>const obj <span class="token operator">=</span> object.assign<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span>, obj1, obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token punctuation">{</span>a: 1,b: 2<span class="token punctuation">}</span></code></pre><p><strong>吐槽</strong><br>ES6的扩展运算符是不是忘记了，还有数组的合并不考虑去重吗？</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">    const a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token punctuation">;</span>    const b <span class="token operator">=</span> <span class="token punctuation">[</span>1,5,6<span class="token punctuation">]</span><span class="token punctuation">;</span>    const c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.new Set<span class="token punctuation">(</span><span class="token punctuation">..</span>.a, <span class="token punctuation">..</span>.b<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> //<span class="token punctuation">[</span>1,2,3,5,6<span class="token punctuation">]</span>    const obj1 <span class="token operator">=</span> <span class="token punctuation">{</span>        a: 1,    <span class="token punctuation">}</span>    const obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>        b: 1,    <span class="token punctuation">}</span>       const obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.obj1, <span class="token punctuation">..</span>.obj2<span class="token punctuation">}</span><span class="token punctuation">;</span> //<span class="token punctuation">{</span>a: 1,b: 1<span class="token punctuation">}</span></code></pre><h2 id="三、关于拼接字符串"><a href="#三、关于拼接字符串" class="headerlink" title="三、关于拼接字符串"></a>三、关于拼接字符串</h2><pre class=" language-bash"><code class="language-bash">const name <span class="token operator">=</span> <span class="token string">'景昊'</span>,const score <span class="token operator">=</span> 59<span class="token punctuation">;</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>if<span class="token punctuation">(</span>score <span class="token operator">></span> 60<span class="token punctuation">)</span><span class="token punctuation">{</span>    result <span class="token operator">=</span> <span class="token variable"><span class="token variable">`</span>$<span class="token punctuation">{</span>name<span class="token punctuation">}</span>的考试成绩及格<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span>else<span class="token punctuation">{</span>    result <span class="token operator">=</span> <span class="token variable"><span class="token variable">`</span>$<span class="token punctuation">{</span>name<span class="token punctuation">}</span>的考试成绩不及格<span class="token variable">`</span></span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>吐槽</strong><br>像上面这样用ES6字符串模板，还不如不用，你们根本不清楚在<code>$&#123;&#125;</code>中可以做什么操作，在<code>$&#123;&#125;</code>中可以放任意的JavaScript表达式，可以进行运算，也可以引用对象属性。</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">const name <span class="token operator">=</span> <span class="token string">'景昊'</span>,const score <span class="token operator">=</span> 59<span class="token punctuation">;</span>const result <span class="token operator">=</span> `<span class="token variable">${name}</span>$<span class="token punctuation">{</span>score <span class="token operator">></span> 60?<span class="token string">'的考试成绩及格'</span> <span class="token keyword">:</span> <span class="token string">'的考试成绩不及格'</span><span class="token punctuation">}</span>`<span class="token punctuation">;</span></code></pre><h2 id="四、关于if中判断条件"><a href="#四、关于if中判断条件" class="headerlink" title="四、关于if中判断条件"></a>四、关于if中判断条件</h2><pre class=" language-bash"><code class="language-bash">if<span class="token punctuation">(</span>type <span class="token operator">==</span> 1 <span class="token operator">||</span>   <span class="token function">type</span> <span class="token operator">==</span> 2 <span class="token operator">||</span>   <span class="token function">type</span> <span class="token operator">==</span> 3 <span class="token operator">||</span>   <span class="token function">type</span> <span class="token operator">==</span> 4 <span class="token operator">||</span>   <span class="token function">type</span> <span class="token operator">==</span> 5 <span class="token operator">||</span>    <span class="token punctuation">)</span><span class="token punctuation">{</span>    //<span class="token punctuation">..</span>.<span class="token punctuation">}</span> </code></pre><p><strong>吐槽</strong><br>ES6中数组实例方法<code>includes</code>不会使用吗？</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">const conditions <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5<span class="token punctuation">]</span><span class="token punctuation">;</span>if<span class="token punctuation">(</span>condition.includes<span class="token punctuation">(</span>type<span class="token punctuation">))</span><span class="token punctuation">{</span>    //<span class="token punctuation">..</span>.<span class="token punctuation">}</span></code></pre><h2 id="五、关于列表搜索"><a href="#五、关于列表搜索" class="headerlink" title="五、关于列表搜索"></a>五、关于列表搜索</h2><p>在项目中，一些没分页的列表的搜索功能由前端来实现，搜索一般分为精准搜索和模糊搜索。搜索也叫过滤，一般用<code>filter</code>来实现。</p><pre class=" language-bash"><code class="language-bash">const a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5<span class="token punctuation">]</span><span class="token punctuation">;</span>const result <span class="token operator">=</span> a.filter<span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> item <span class="token operator">==</span><span class="token operator">=</span> 3<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p><strong>吐槽</strong><br>如果是精准搜索不会用ES6中的<code>find</code>吗？性能优化懂吗，<code>find</code>方法中找到符合条件的项，就不会继续遍历数组</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">const a <span class="token operator">=</span> <span class="token punctuation">[</span>1,2,3,4,5<span class="token punctuation">]</span><span class="token punctuation">;</span>const result <span class="token operator">=</span> a.find<span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> item <span class="token operator">==</span><span class="token operator">=</span> 3<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h2 id="六、关于扁平化数组"><a href="#六、关于扁平化数组" class="headerlink" title="六、关于扁平化数组"></a>六、关于扁平化数组</h2><p>一个部门JSON数据，属性名是部门id，属性值是各部门成员id数组集合，现在要把有的部门的成员id都提取到一个数组集合中。</p><pre class=" language-bash"><code class="language-bash">const deps <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'采购部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span>,    <span class="token string">'人事部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>5,8,12<span class="token punctuation">]</span>,    <span class="token string">'运输部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>5,14,79<span class="token punctuation">]</span>,    <span class="token string">'行政部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>3,64,105<span class="token punctuation">]</span>,<span class="token punctuation">}</span><span class="token keyword">let</span> member <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>let item <span class="token keyword">in</span> deps<span class="token punctuation">)</span> <span class="token punctuation">{</span>    const value <span class="token operator">=</span> deps<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">;</span>    if<span class="token punctuation">(</span>Array.isArray<span class="token punctuation">(</span>value<span class="token punctuation">))</span><span class="token punctuation">{</span>        member <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.member, <span class="token punctuation">..</span>.value<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>member <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.new Set<span class="token punctuation">(</span>member<span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p><strong>吐槽</strong><br>获取对象的全部属性值还要遍历吗？<code>Object.values</code>忘记了吗？还有涉及到数组的扁平化处理，为啥不用ES6提供的<code>flat</code>方法呢，还好这次的数组的深度最多只有2维，要是遇到4维、5维深度的数组，是不是循环嵌套循环来扁平化？</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">const deps <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'采购部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span>,    <span class="token string">'人事部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>5,8,12<span class="token punctuation">]</span>,    <span class="token string">'运输部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>5,14,79<span class="token punctuation">]</span>,    <span class="token string">'行政部'</span><span class="token keyword">:</span> <span class="token punctuation">[</span>3,64,105<span class="token punctuation">]</span>,<span class="token punctuation">}</span><span class="token keyword">let</span> member <span class="token operator">=</span> Object.values<span class="token punctuation">(</span>deps<span class="token punctuation">)</span>.flat<span class="token punctuation">(</span>Infinity<span class="token punctuation">)</span></code></pre><p>其中使用<code>Infinity</code>作为<code>flat</code>的参数，使得无需知道被扁平化的数组的维度。</p><p><strong>补充</strong><br><code>flat</code>方法不支持IE浏览器</p><h2 id="七、关于获取对象属性"><a href="#七、关于获取对象属性" class="headerlink" title="七、关于获取对象属性"></a>七、关于获取对象属性</h2><pre class=" language-bash"><code class="language-bash">const name <span class="token operator">=</span> obj <span class="token operator">&amp;&amp;</span> obj.name<span class="token punctuation">;</span></code></pre><p><strong>吐槽</strong><br>ES6中的可选链操作符会使用吗？</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">const name <span class="token operator">=</span> obj?.name<span class="token punctuation">;</span></code></pre><h2 id="八、关于添加对象属性"><a href="#八、关于添加对象属性" class="headerlink" title="八、关于添加对象属性"></a>八、关于添加对象属性</h2><p>当给对象添加属性时，如果属性名是动态变化的，该怎么处理。</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> index <span class="token operator">=</span> 1<span class="token punctuation">;</span><span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token variable"><span class="token variable">`</span>topic$<span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token punctuation">;</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'话题内容'</span><span class="token punctuation">;</span></code></pre><p><strong>吐槽</strong><br>为何要额外创建一个变量。不知道ES6中的对象属性名是可以用表达式吗？</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">let</span> index <span class="token operator">=</span> 1<span class="token punctuation">;</span>obj<span class="token punctuation">[</span><span class="token variable"><span class="token variable">`</span>topic$<span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'话题内容'</span><span class="token punctuation">;</span></code></pre><h2 id="九、关于输入框非空的判断"><a href="#九、关于输入框非空的判断" class="headerlink" title="九、关于输入框非空的判断"></a>九、关于输入框非空的判断</h2><p>在处理输入框相关业务时，往往会判断输入框未输入值的场景。</p><pre class=" language-bash"><code class="language-bash">if<span class="token punctuation">(</span>value <span class="token operator">!=</span><span class="token operator">=</span> null <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span><span class="token operator">=</span> undefined <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //<span class="token punctuation">..</span>.<span class="token punctuation">}</span></code></pre><p><strong>吐槽</strong><br>ES6中新出的空值合并运算符了解过吗，要写那么多条件吗？</p><pre class=" language-bash"><code class="language-bash">if<span class="token punctuation">((</span>value??<span class="token string">''</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //<span class="token punctuation">..</span>.<span class="token punctuation">}</span></code></pre><h2 id="十、关于异步函数"><a href="#十、关于异步函数" class="headerlink" title="十、关于异步函数"></a>十、关于异步函数</h2><p>异步函数很常见，经常是用Promise来实现</p><pre class=" language-bash"><code class="language-bash">const fn1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            resolve<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>, 300<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>const fn2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new Promise<span class="token punctuation">((</span>resolve, reject<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        setTimeout<span class="token punctuation">((</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            resolve<span class="token punctuation">(</span>2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>, 600<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>const fn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    fn1.then<span class="token punctuation">(</span>res1 <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span>res1<span class="token punctuation">)</span><span class="token punctuation">;</span> //1        fn2<span class="token punctuation">(</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>res2 <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            console.log<span class="token punctuation">(</span>res2<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>吐槽</strong><br>如果这样调用异步函数，不怕形成地域回调吗？</p><p><strong>改进</strong></p><pre class=" language-bash"><code class="language-bash">const fn <span class="token operator">=</span> async<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    const res1 <span class="token operator">=</span> await fn1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cosnt res2 <span class="token operator">=</span> await fn2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    console.log<span class="token punctuation">(</span>res1<span class="token punctuation">)</span><span class="token punctuation">;</span> //1    console.log<span class="token punctuation">(</span>res2<span class="token punctuation">)</span><span class="token punctuation">;</span> //2<span class="token punctuation">}</span></code></pre><p><strong>补充</strong><br>但是要做并发请求时，还是要用到<code>Promise.all()</code></p><pre class=" language-bash"><code class="language-bash">const fn <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    Promise.all<span class="token punctuation">(</span><span class="token punctuation">[</span>fn1<span class="token punctuation">(</span><span class="token punctuation">)</span>, fn2<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>.then<span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span> //<span class="token punctuation">[</span>1,2<span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果并发请求时，只要其中一个异步函数处理完成，就返回结果，要用到<code>Promise.race()</code></p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue通信（组件间传值）</title>
      <link href="/2022/01/06/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC/"/>
      <url>/2022/01/06/vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vue组件间传值"><a href="#Vue组件间传值" class="headerlink" title="Vue组件间传值"></a>Vue组件间传值</h2><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ol><li><strong>作用：</strong> 用于给节点打标识</li></ol><blockquote><p>被用来给元素或子组件注册引用信息（id的替代者）；</p></blockquote><blockquote><p>应用在html标签上获取真实DOM元素，应用在组件标签上是组件实例对象（vc）</p></blockquote><ol start="2"><li><strong>读取方式：</strong> this.$refs.xxxxx</li></ol><blockquote><p>打标识：<code>&lt;h1 ref= &#39;xxx&#39;&gt;.....&lt;/h1&gt;</code>或<code>&lt;School ref= &#39;xxx&#39;&gt;&lt;/School&gt;</code></p></blockquote><blockquote><p>获取：this.$refs.xxx</p></blockquote><h3 id="一、props（父传子）"><a href="#一、props（父传子）" class="headerlink" title="一、props（父传子）"></a>一、props（父传子）</h3><ol><li><strong>作用：</strong> 用于父组件给子组件传递数据</li></ol><blockquote><p>功能：让组件接收外部传过来的数据</p></blockquote><ol start="2"><li><p>传递数据： <code>&lt;Demo name=&#39;xxx&#39; :age=&#39;xxx&#39; :setName=&#39;xxx&#39;/&gt;</code></p></li><li><p>接收数据：</p></li></ol><ul><li><strong>读取方式一：只接收名称</strong></li></ul><pre class=" language-bash"><code class="language-bash">props:<span class="token punctuation">[</span><span class="token string">'name'</span>,<span class="token string">'age'</span>,<span class="token string">'setName'</span><span class="token punctuation">]</span></code></pre><ul><li><strong>读取方式二：</strong> 限制名称和类型</li></ul><pre class=" language-bash"><code class="language-bash">props:<span class="token punctuation">{</span>    name: String,    age: Number,    setName: Function<span class="token punctuation">}</span></code></pre><ul><li><strong>读取方式三：</strong> 限制名称/类型/必要性/默认值</li></ul><pre class=" language-bash"><code class="language-bash">props:<span class="token punctuation">{</span>    name:<span class="token punctuation">{</span>        type: String, //类型        required: true, //必要性        default: xxx //默认值    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实要进行修改，那么请复制props的内容到data中一份，然后去修改data中的数据。===&gt; v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p></blockquote><h3 id="组件化编码流程（通用）"><a href="#组件化编码流程（通用）" class="headerlink" title="组件化编码流程（通用）"></a>组件化编码流程（通用）</h3><ol><li><p>拆分静态组件：组件要按照功能点拆分抽取，命名不要与html元素冲突</p></li><li><p>实现动态组件：数据的类型、名称是什么，考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p><p> 2.1 一个组件在用：放在组件自身即可</p><p> 2.2 一些组件在用: 放在他们的共同的父组件上（状态提升）</p></li><li><p>交互——从绑定事件监听开始</p></li></ol><h3 id="二、组件的自定义事件（子传父）"><a href="#二、组件的自定义事件（子传父）" class="headerlink" title="二、组件的自定义事件（子传父）"></a>二、组件的自定义事件（子传父）</h3><blockquote><p>使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<code>事件的回调在A中</code>）</p></blockquote><ol><li><strong>绑定自定义事件</strong></li></ol><pre class=" language-bash"><code class="language-bash">在父组件中：<span class="token operator">&lt;</span>Header @addTodo<span class="token operator">=</span><span class="token string">"addTodo"</span>/<span class="token operator">></span>或<span class="token operator">&lt;</span>Header ref<span class="token operator">=</span><span class="token string">"header"</span>/<span class="token operator">></span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>mounted<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    this.<span class="token variable">$refs</span>.header.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'addTodo'</span>, this.addTodo<span class="token punctuation">)</span>  // 回调配置在methods中    或 this.<span class="token variable">$refs</span>.header.<span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'addTodo'</span>,<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> // 回调使用箭头函数<span class="token punctuation">}</span></code></pre><blockquote><p>若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法</p></blockquote><ol start="2"><li><strong>触发自定义事件</strong></li></ol><pre class=" language-bash"><code class="language-bash">在子组件中：this.<span class="token variable">$emit</span><span class="token punctuation">(</span><span class="token string">'addTodo'</span>, 数据<span class="token punctuation">)</span></code></pre><ol start="3"><li><strong>解绑自定义事件</strong></li></ol><pre class=" language-bash"><code class="language-bash">在子组件中：this.<span class="token variable">$off</span><span class="token punctuation">(</span><span class="token string">'addTodo'</span><span class="token punctuation">)</span></code></pre><blockquote><p>组件上可以绑定原生DOM事件，需要使用native修饰符</p></blockquote><blockquote><p>注意：通过this.$refs.header.$on(‘addTodo’, 回调)绑定自定义事件时，回调<code>要么配置在methods中，要么用箭头函数</code>，否则this指向会出问题!</p></blockquote><h3 id="三、全局事件总线（任意）"><a href="#三、全局事件总线（任意）" class="headerlink" title="三、全局事件总线（任意）"></a>三、全局事件总线（任意）</h3><ol><li>一种组件间通信的方式，适用于<code>任意组件间通信</code></li></ol><blockquote><p>Vue原型对象上包含事件处理的方法</p><blockquote><p>$on(eventName, listener): 绑定自定义事件监听<br>$emit(eventName, data): 分发自定义事件<br>$off(eventName): 解绑自定义事件<br>$once(eventName, listener): 绑定事件监听，但只能处理一次</p></blockquote></blockquote><blockquote><p>所有组件实例对象的原型对象的原型对象就是Vue的原型对象</p><blockquote><p>所有组件对象都能看到Vue原型对象上的属性和方法<br>Vue.prototype.$bus = new Vue(),所有组件对象都能看到$bus这个属性对象</p></blockquote></blockquote><blockquote><p>全局事件总线</p><blockquote><p>包含事件处理相关方法的对象（只有一个）<br>所有组件都可以得到</p></blockquote></blockquote><ol start="2"><li>安装全局事件总线：</li></ol><pre class=" language-bash"><code class="language-bash">入口文件main.js中：new Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    beforeCreate<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> // 尽量早的执行挂载全局事件总线对象的操作        Vue.prototype.<span class="token variable">$bus</span> <span class="token operator">=</span> this // 安装全局事件总线，<span class="token variable">$bus</span>就是当前应用的vm    <span class="token punctuation">}</span>    <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">}</span><span class="token punctuation">)</span>.<span class="token variable">$mount</span><span class="token punctuation">(</span><span class="token string">'#root'</span><span class="token punctuation">)</span></code></pre><ol start="3"><li><p>绑定事件（使用事件总线）：</p><p> 3.1 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<code>回调留在A组件自身</code></p><pre class=" language-bash"><code class="language-bash">methods<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    demo<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>mounted<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.<span class="token variable">$bus</span><span class="token keyword">.</span><span class="token variable">$on</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span>,this.demo<span class="token punctuation">)</span><span class="token punctuation">}</span>beforeDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.<span class="token variable">$bus</span><span class="token keyword">.</span><span class="token variable">$off</span><span class="token punctuation">(</span>'xxxx<span class="token punctuation">)</span> // 解绑事件：最好在beforeDestroy钩子中，用<span class="token variable">$off</span>去解绑<span class="token variable"><span class="token variable">`</span>当前组件所用到的<span class="token variable">`</span></span>事件<span class="token punctuation">}</span></code></pre><p> 3.2 分发事件（提供数据）：this.$bus.$emit(‘xxxx’, 数据)</p></li></ol><h3 id="四、消息订阅与发布（任意）"><a href="#四、消息订阅与发布（任意）" class="headerlink" title="四、消息订阅与发布（任意）"></a>四、消息订阅与发布（任意）</h3><ol><li>一种组件间通信的方式，适用于<code>任意组件间通信</code></li></ol><blockquote><p>与全局事件总线很相似，但需要引入第三方库，更推荐使用全局事件总线</p></blockquote><blockquote><p>它包含以下操作：</p><blockquote><p>订阅消息 –对应绑定事件监听<br>发布消息 –分发事件<br>取消消息订阅 –解绑事件监听</p></blockquote></blockquote><blockquote><p>相关语法：</p><blockquote><p>pubsub.subscribe(‘msgName’, function(msgName, data){ })<br>pubsub.publish(‘msgName’, data)<br>pubsub.unsubscribe(token)</p></blockquote></blockquote><ol start="2"><li><p>使用步骤</p><p> 2.1 安装pubsub: npm i -S pubsub-js</p><p> 2.2 引入：import pubsub from ‘pubsub-js’</p><p> 2.3 接受数据：A组件想接受数据，则在A组件中订阅消息，订阅的<code>回调留在A组件自身</code></p><pre class=" language-bash"><code class="language-bash">methods<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    demo<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>mounted<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    this.pid <span class="token operator">=</span> pubsub.subscribe<span class="token punctuation">(</span><span class="token string">'xxx'</span>, this.demo<span class="token punctuation">)</span> // 订阅消息<span class="token punctuation">}</span>beforeDestroy<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pubsub.unsubscribe<span class="token punctuation">(</span>this.pid<span class="token punctuation">)</span> //最好在beforeDestroy钩子中，用pubSub.unsubscribe<span class="token punctuation">(</span>this.pid<span class="token punctuation">)</span>去<span class="token variable"><span class="token variable">`</span>取消订阅<span class="token variable">`</span></span><span class="token punctuation">}</span></code></pre><p> 2.4 提供数据：pubsub.publish(‘xxx’, 数据) // 发布消息</p></li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><ol><li><p>语法： this.$nextTick(回调函数)</p></li><li><p>作用：在下一次DOM更新结束后执行其指定的回调</p></li><li><p>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行</p></li></ol><h3 id="五、插槽（父传子）"><a href="#五、插槽（父传子）" class="headerlink" title="五、插槽（父传子）"></a>五、插槽（父传子）</h3><ol><li>作用：让父组件可以向子组件指定位置插入<code>html结构</code>，也是一种组件间通信的方式，适用于<code>父组件===&gt;子组件</code></li></ol><blockquote><p>父组件向子组件传递<code>带数据</code>的标签，当一个组件有不确定的结构时，就需要使用slot技术。注意：插槽内容是在父组件中编译后，再传递给子组件的。</p></blockquote><ol start="2"><li><p>分类：默认插槽、具名插槽、作用域插槽</p></li><li><p>使用方式：</p><ul><li>默认插槽：</li></ul><pre class=" language-bash"><code class="language-bash">父组件中：    <span class="token operator">&lt;</span>Category<span class="token operator">></span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>html结构<span class="token operator">&lt;</span>/div<span class="token operator">></span>    <span class="token operator">&lt;</span>/Category<span class="token operator">></span>子组件中：    <span class="token operator">&lt;</span>template<span class="token operator">></span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 定义插槽 --<span class="token operator">></span>            <span class="token operator">&lt;</span>slot<span class="token operator">></span>插槽默认内容<span class="token punctuation">..</span>.<span class="token operator">&lt;</span>/slot<span class="token operator">></span>        <span class="token operator">&lt;</span>/div<span class="token operator">></span>    <span class="token operator">&lt;</span>/template<span class="token operator">></span></code></pre><ul><li>具名插槽：</li></ul><pre class=" language-bash"><code class="language-bash">  父组件中：    <span class="token operator">&lt;</span>Category<span class="token operator">></span>        <span class="token operator">&lt;</span>template slot<span class="token operator">=</span> <span class="token string">"center"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>div<span class="token operator">></span>html结构1<span class="token operator">&lt;</span>/div<span class="token operator">></span>        <span class="token operator">&lt;</span>/template<span class="token operator">></span>        <span class="token operator">&lt;</span>template v-slot: footer<span class="token operator">></span>            <span class="token operator">&lt;</span>div<span class="token operator">></span>html结构2<span class="token operator">&lt;</span>/div<span class="token operator">></span>        <span class="token operator">&lt;</span>/template<span class="token operator">></span>    <span class="token operator">&lt;</span>/Category<span class="token operator">></span>子组件中：    <span class="token operator">&lt;</span>template<span class="token operator">></span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 定义插槽 --<span class="token operator">></span>            <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">"center"</span><span class="token operator">></span>插槽默认内容<span class="token punctuation">..</span>.<span class="token operator">&lt;</span>/slot<span class="token operator">></span>            <span class="token operator">&lt;</span>slot name<span class="token operator">=</span><span class="token string">"footer"</span><span class="token operator">></span>插槽默认内容<span class="token punctuation">..</span>.<span class="token operator">&lt;</span>/slot<span class="token operator">></span>        <span class="token operator">&lt;</span>/div<span class="token operator">></span>    <span class="token operator">&lt;</span>/template<span class="token operator">></span></code></pre><ul><li><p>作用域插槽：</p><ol><li><p>理解：<code>数据在组件（儿子）的自身，但根据数据生成的结构需要组件的使用者（爹）来决定</code>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p></li><li><p>具体代码：</p></li></ol><pre class=" language-bash"><code class="language-bash">父组件中：    <span class="token operator">&lt;</span>Category<span class="token operator">></span>        <span class="token operator">&lt;</span>template scope <span class="token operator">=</span> <span class="token string">"scopeData"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 生成的是ul列表 --<span class="token operator">></span>            <span class="token operator">&lt;</span>ul<span class="token operator">></span>                <span class="token operator">&lt;</span>li v-for<span class="token operator">=</span><span class="token string">"g in scopedData.games"</span> :key<span class="token operator">=</span><span class="token string">"g"</span><span class="token operator">></span>                    <span class="token punctuation">{</span><span class="token punctuation">{</span>g<span class="token punctuation">}</span><span class="token punctuation">}</span>                <span class="token operator">&lt;</span>/li<span class="token operator">></span>            <span class="token operator">&lt;</span>/ul<span class="token operator">></span>        <span class="token operator">&lt;</span>/template<span class="token operator">></span>    <span class="token operator">&lt;</span>Category<span class="token operator">></span>    <span class="token operator">&lt;</span>Category<span class="token operator">></span>        <span class="token operator">&lt;</span>template slot-sope <span class="token operator">=</span> <span class="token string">"scopeData"</span><span class="token operator">></span>            <span class="token operator">&lt;</span><span class="token operator">!</span>-- 生成的是h4标题 --<span class="token operator">></span>            <span class="token operator">&lt;</span>h4 v-for <span class="token operator">=</span> <span class="token string">"g in scopedData.games"</span> :key <span class="token operator">=</span> <span class="token string">"g"</span><span class="token operator">></span>                <span class="token punctuation">{</span><span class="token punctuation">{</span>g<span class="token punctuation">}</span><span class="token punctuation">}</span>            <span class="token operator">&lt;</span>/h4<span class="token operator">></span>        <span class="token operator">&lt;</span>/template<span class="token operator">></span>    <span class="token operator">&lt;</span>Category<span class="token operator">></span>子组件中：    <span class="token operator">&lt;</span>template<span class="token operator">></span>        <span class="token operator">&lt;</span>div<span class="token operator">></span>            <span class="token operator">&lt;</span>slot :games<span class="token operator">=</span><span class="token string">"games"</span><span class="token operator">></span><span class="token operator">&lt;</span>/slot<span class="token operator">></span>        <span class="token operator">&lt;</span>/div<span class="token operator">></span>    <span class="token operator">&lt;</span>/template<span class="token operator">></span>    <span class="token operator">&lt;</span>script<span class="token operator">></span>        <span class="token function">export</span> default <span class="token punctuation">{</span>            name: <span class="token string">'Category'</span>,            props: <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span>,            // 数据在子组件自身            data<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token punctuation">{</span>                    games: <span class="token punctuation">[</span><span class="token string">'红色警戒'</span>,<span class="token string">'穿越火线'</span>,<span class="token string">'劲舞团'</span>,<span class="token string">'超级玛丽'</span><span class="token punctuation">]</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token operator">&lt;</span>/script<span class="token operator">></span></code></pre></li></ul></li></ol><h3 id="六、vuex-任意-——共享单车"><a href="#六、vuex-任意-——共享单车" class="headerlink" title="六、vuex(任意)——共享单车"></a>六、vuex(任意)——共享单车</h3><ol><li><strong>概念</strong></li></ol><p>在vue中事件集中式状态（数据）管理的一个vue<code>插件</code>，对Vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，并且适用于任意组件间通信。</p><ol start="2"><li><strong>何时使用？</strong></li></ol><p>多个组件需要共享数据时</p><p><strong>vuex工作原理图</strong></p><p><img src="https://cdn.jsdelivr.net/gh/kincar/image@main/vuex.png" alt="vuex工作原理图" title="vuex工作原理图"></p><ol start="3"><li><p>搭建vuex环境</p><p> （1）创建文件：src/store/index.js</p><pre class=" language-bash"><code class="language-bash">//引入Vue核心库<span class="token function">import</span> Vue from <span class="token string">'vue'</span>//引入Vuex<span class="token function">import</span> Vuex from <span class="token string">'vuex'</span>//应用Vuex插件Vue.use<span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>//准备actions对象--响应组件中用户的动作const actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>//准备mutations对象--修改state中的数据const mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>//准备state对象--保存具体的数据const state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>//创建并暴露store<span class="token function">export</span> default new Vuex.Store<span class="token punctuation">(</span><span class="token punctuation">{</span>    actions,    mutations,    state<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> （2）在main.js中创建vm时传入store配置项</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>//引入store<span class="token function">import</span> store from <span class="token string">'./store'</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>//创建vmnew Vue<span class="token punctuation">(</span><span class="token punctuation">{</span>    el: <span class="token string">'#app'</span>,    render: h<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>,    store<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>基本使用</p><blockquote><p>vuex核心概念和API</p><blockquote><p><strong>store（营业执照）</strong><br><strong>state（菜）：</strong><br>vuex管理的状态对象；<br>它应该是唯一的<br><strong>actinos（传菜员）：</strong><br>值是一个对象，包含多个响应用户动作的回调函数；<br>通过commit()来触发mutation中函数的调用，<code>间接更新</code>state；<br>如何触发actions中的回调？ == 在组件中使用<code>$store.dispatch(&#39;对应的action回调名&#39;)</code>触发；<br>可以包含异步代码（定时器，Ajax等等）<br><strong>mutations（大厨）：</strong><br>值是一个对象，包含多个<code>直接更新</code>state的方法;<br>谁能调用mutations中的方法？如何调用？ == 在action中使用：commit(‘对应的mutation是方法名’)触发<br>mutations中方法的特点：不能写异步代码、只能单纯的操作state<br><strong>getters（调料）：</strong><br>值为一个对象，包含多个用于返回数据的函数<br>如何使用？ == $store.getters.xxx</p></blockquote></blockquote><p> （1）初始化数据、配置actions、配置mutations，操作文件store.js</p><pre class=" language-bash"><code class="language-bash">//引入Vue核心库<span class="token function">import</span> Vue from <span class="token string">'vue'</span>//引入Vuex<span class="token function">import</span> Vuex from <span class="token string">'vuex'</span>//应用Vuex插件Vue.use<span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span>const actions <span class="token operator">=</span> <span class="token punctuation">{</span>    //响应组件中加的动作    jia<span class="token punctuation">(</span>context,value<span class="token punctuation">)</span><span class="token punctuation">{</span>        //context（上下文），mini版Store        console.log<span class="token punctuation">(</span><span class="token string">'actions中的jia被调用了'</span><span class="token punctuation">)</span>        context.commit<span class="token punctuation">(</span><span class="token string">'JIA'</span>,value<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>const mutations <span class="token operator">=</span> <span class="token punctuation">{</span>    //执行加    JIA<span class="token punctuation">(</span>state,value<span class="token punctuation">)</span><span class="token punctuation">{</span>        console.log<span class="token punctuation">(</span><span class="token string">'mutations中的JIA被调用了'</span><span class="token punctuation">)</span>        state.sum +<span class="token operator">=</span> value    <span class="token punctuation">}</span><span class="token punctuation">}</span>//初始化数据const state <span class="token operator">=</span> <span class="token punctuation">{</span>    sum: 0<span class="token punctuation">}</span>//创建并暴露store<span class="token function">export</span> default new Vuex.Store<span class="token punctuation">(</span><span class="token punctuation">{</span>    actions,    mutations,    state,<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> （2）组件中读取Vuex中的数据：$store.state.sum</p><p> （3）组件中修改Vuex中的数据：$store.dispatch(‘actions中的方法名’,数据)或$store.commit(‘mutations中的方法名’,数据)</p><blockquote><p>备注：若没有<code>网络请求或其他业务逻辑</code>，组件中也可以越过actions，即不写<code>dispatch</code>，直接写<code>commit</code></p></blockquote></li><li><p>getters的使用</p><p> （1）概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p><p> （2）在store.js中追加getters配置</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>const getters <span class="token operator">=</span> <span class="token punctuation">{</span>    bigSum<span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> state.sum * 10    <span class="token punctuation">}</span><span class="token punctuation">}</span>//创建并暴露store<span class="token function">export</span> default new Vuex.Store<span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span>    getters<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> （3）组件中读取数据：$store.getters.bigSum</p></li><li><p>四个map方法的使用（简化代码–推荐使用！不用再写state、getters、commit、diapatch之类的，vuex内部帮我们封装好了）</p><p> （1）<strong>mapState方法：</strong>用于帮助我们映射state中的数据为计算属性</p><pre class=" language-bash"><code class="language-bash">computed: <span class="token punctuation">{</span>    //借助mapState生成计算属性：sum、school、subject（对象写法）    <span class="token punctuation">..</span>.mapState<span class="token punctuation">(</span><span class="token punctuation">{</span>sum:<span class="token string">'sum'</span>, school:<span class="token string">'school'</span>, subject:<span class="token string">'subject'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    //借助mapState生成计算属性：sum、school、subject（数组写法）--推荐使用，更简单！    <span class="token punctuation">..</span>.mapState<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sum'</span>, <span class="token string">'school'</span>, <span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p> （2）<strong>mapGetters方法：</strong>用于帮助我们映射getters中的数据为计算属性</p><pre class=" language-bash"><code class="language-bash">computed: <span class="token punctuation">{</span>    //借助mapGetters生成计算属性：bigSum（对象写法）    <span class="token punctuation">..</span>.mapGetters<span class="token punctuation">(</span><span class="token punctuation">{</span>bigSum:<span class="token string">'bigSum'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    //借助mapGetters生成计算属性：bigSum（数组写法）--推荐使用，更简单！    <span class="token punctuation">..</span>.mapGetters<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'bigSum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p> （3）<strong>mapActions方法：</strong>用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数</p><pre class=" language-bash"><code class="language-bash">methods: <span class="token punctuation">{</span>    //靠mapActions生成：incrementOdd、incrementWait（对象形式）    <span class="token punctuation">..</span>.mapActions<span class="token punctuation">(</span><span class="token punctuation">{</span>incrementOdd: <span class="token string">'jiaOdd'</span>, incrementWait: <span class="token string">'jiaWait'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    //靠mapActions生成：incrementOdd、incrementWait（数组形式）    <span class="token punctuation">..</span>.mapActions<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'jiaOdd'</span>,<span class="token string">'jiaWait'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p> （4）<strong>mapMutations方法：</strong>用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数</p><pre class=" language-bash"><code class="language-bash">methods: <span class="token punctuation">{</span>    //靠mapMutations生成：increment、decrement（对象形式）    <span class="token punctuation">..</span>.mapMutatinos<span class="token punctuation">(</span><span class="token punctuation">{</span>increment:<span class="token string">'JIA'</span>, decrement:<span class="token string">'JIAN'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    //靠mapMutations生成：JIA、JIAN（数组形式）    <span class="token punctuation">..</span>.mapMutations<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'JIA'</span>,<span class="token string">'JIAN'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>h1<span class="token operator">></span>当前求和为：<span class="token punctuation">{</span><span class="token punctuation">{</span>sum<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/h1<span class="token operator">></span><span class="token operator">&lt;</span>h3<span class="token operator">></span>当前求和放大10倍为：<span class="token punctuation">{</span><span class="token punctuation">{</span>bigSum<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/h3<span class="token operator">></span><span class="token operator">&lt;</span>h3<span class="token operator">></span>我在<span class="token punctuation">{</span><span class="token punctuation">{</span>school<span class="token punctuation">}</span><span class="token punctuation">}</span>，学习<span class="token punctuation">{</span><span class="token punctuation">{</span>subject<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span>/h3<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"increment(n)"</span><span class="token operator">></span>+<span class="token operator">&lt;</span>/button<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"decrement(n)"</span><span class="token operator">></span>-<span class="token operator">&lt;</span>/button<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"incrementOdd(n)"</span><span class="token operator">></span>当前求和为奇数再加<span class="token operator">&lt;</span>/button<span class="token operator">></span><span class="token operator">&lt;</span>button @click<span class="token operator">=</span><span class="token string">"incrementWait(n)"</span><span class="token operator">></span>等一等再加<span class="token operator">&lt;</span>/button<span class="token operator">></span></code></pre></li><li><p><strong>模块化+命名空间</strong></p><p> （1）目的：让代码更好维护，让多种数据分类更加明确</p><p> （2）修改store.js</p><blockquote><p>包含多个moudule；一个module是一个store的配置对象；与一个组件（包含共享数据）对应</p></blockquote><pre class=" language-bash"><code class="language-bash">const countAbout <span class="token operator">=</span> <span class="token punctuation">{</span>    namespaced: true, //开启命名空间    state: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,    mutations: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,    getters: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">}</span>const personAbout <span class="token operator">=</span> <span class="token punctuation">{</span>    namespaced: true, //开启命名空间    state: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,    mutations: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>,    actions: <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">export</span> default new Vuex.Store<span class="token punctuation">(</span><span class="token punctuation">{</span>    modules: <span class="token punctuation">{</span>        countAbout,        personAbout    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> （3）开启命名空间后，组件中读取state数据：</p><pre class=" language-bash"><code class="language-bash">//方式一：自己直接读取this.<span class="token variable">$store</span>.state.personAbout.list//方式二：借助mapState读取：<span class="token punctuation">..</span>.mapState<span class="token punctuation">(</span><span class="token string">'countAbout'</span>,<span class="token punctuation">[</span><span class="token string">'sum'</span>,<span class="token string">'school'</span>,<span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p> （4）开启命名空间后，组件中读取getters数据：</p><pre class=" language-bash"><code class="language-bash">//方式一：自己直接dispatchthis.<span class="token variable">$store</span>.dispatch<span class="token punctuation">(</span><span class="token string">'personAbout/addPersonWang'</span>, person<span class="token punctuation">)</span>//方式二：借助mapGetters读取<span class="token punctuation">..</span>.mapGetters<span class="token punctuation">(</span><span class="token string">'countAbout'</span>,<span class="token punctuation">[</span><span class="token string">'bigSum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p> （5）开启命名空间后，组件中调用dispatch</p><pre class=" language-bash"><code class="language-bash">//方式一：自己直接dispatchthis.<span class="token variable">$store</span>.dispatch<span class="token punctuation">(</span><span class="token string">'personAbout/addPersonWang'</span>,perosn<span class="token punctuation">)</span>//方拾二：借助mapActions：<span class="token punctuation">..</span>.mapActions<span class="token punctuation">(</span><span class="token string">'countAbout'</span>,<span class="token punctuation">{</span>incrementOdd:<span class="token string">'jiaOdd'</span>, incrementWait:<span class="token string">'jiaWait'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p> （6）开启命名空间后，组件中调用commit</p><pre class=" language-bash"><code class="language-bash">//方式一：自己直接committhis.<span class="token variable">$store</span>.commit<span class="token punctuation">(</span><span class="token string">'personAbout/ADD_PERSON'</span>, person<span class="token punctuation">)</span>//方式二：借助mapMutations：<span class="token punctuation">..</span>.mapMutations<span class="token punctuation">(</span><span class="token string">'countAbout'</span>,<span class="token punctuation">{</span>increment:<span class="token string">'JIA'</span>, decrement:<span class="token string">'JIAN'</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 通信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue常用内置指令</title>
      <link href="/2022/01/03/vue%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/"/>
      <url>/2022/01/03/vue%E5%86%85%E7%BD%AE%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Vue-常用内置指令"><a href="#Vue-常用内置指令" class="headerlink" title="Vue 常用内置指令"></a>Vue 常用内置指令</h2><blockquote><p>模板语法分为两类：插值语法和指令语法</p><blockquote><p><strong>插值语法</strong>：用于解析标签体内容。<br>写法是<code>&#123;&#123;xxx&#125;&#125;</code>，xxx 是 js 表达式，并且可以直接读取到 data 中的所有属性<br><strong>指令语法</strong>：用于解析标签（包含：标签属性、标签体内容、绑定事件…）<br>举例：v-bind:href = “xxx”或简写为:href= “xxx”，xxx 同样是 js 表达式，并且可以直接读取到 data 中的所有属性。<br>注意：Vue 中有很多指令，并且形式都是 v-???</p></blockquote></blockquote><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul><li><p>更新元素的<code>textContent</code></p></li><li><p>向指定节点渲染文本内容，会替换掉原节点内容</p></li></ul><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul><li><p>更新元素的<code>innerHTML</code></p></li><li><p>向指定节点渲染包含 HTML 结构的内容，会替换掉原节点的内容</p></li><li><p>严重注意：有安全性问题，容易导致 XSS 攻击，一定要用在可信的内容上，永远不要用在用户提交的内容上</p></li></ul><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul><li><p>如果为 true，当前标签才会输出到页面</p></li><li><p>动态控制节点是否存在</p></li><li><p>不展示的 DOM 元素直接被移除，适用于切换频率较低的场景</p></li></ul><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul><li><p>如果为 false，当前标签才会输出到页面</p></li><li><p>与 v-if、v-else-if 搭配使用</p></li></ul><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul><li><p>通过控制 diaplay 样式来控制显示/隐藏</p></li><li><p>动态控制节点是否展示</p></li><li><p>不展示的 DOM 元素未被移除，仅仅是使用样式隐藏掉，适用于切换频率较高的场景</p></li></ul><h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul><li>遍历数组、对象、字符串</li></ul><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul><li>绑定事件监听，一般简写为 <code>@</code></li></ul><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul><li><p>绑定解析表达式，一般简写为 <code>:xxx</code></p></li><li><p>单向数据绑定。数据只能从 data 流向页面</p></li></ul><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul><li><p>双向数据绑定。数据不仅能从 data 流向页面，还可以从页面流向 data</p></li><li><p>一般都应用在<code>表单类</code>元素上（如：input、select）</p></li><li><p>v-model:value 可简写为<code> v-model</code>，因为它默认收集的就是 value 值</p></li></ul><h3 id="v-cloak（没有值）"><a href="#v-cloak（没有值）" class="headerlink" title="v-cloak（没有值）"></a>v-cloak（没有值）</h3><ul><li><p>vue 实例创建完毕并接管容器后，会删除掉 v-cloak 属性</p></li><li><p>与 css 配合：<code>[v-cloak]&#123;diaplay: none&#125;</code>可以解决网速慢时页面展示出的问题</p></li></ul><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul><li>所在节点初次动态渲染后，就视为静态内容了。以后的数据结构改变不会引起 v-once 所在结构的更新，可以用于优化性能</li></ul><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul><li>跳过其所在节点的编译过程，可以用它来跳过没有使用指令语法、插值语法的节点，加快编译</li></ul>]]></content>
      
      
      <categories>
          
          <category> 指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中的key</title>
      <link href="/2022/01/02/vue%E4%B8%AD%E7%9A%84key/"/>
      <url>/2022/01/02/vue%E4%B8%AD%E7%9A%84key/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Vue、React-中的-key-有什么作用？"><a href="#Vue、React-中的-key-有什么作用？" class="headerlink" title="Vue、React 中的 key 有什么作用？"></a>Vue、React 中的 key 有什么作用？</h1><h2 id="虚拟-DOM-中-key-的作用"><a href="#虚拟-DOM-中-key-的作用" class="headerlink" title="虚拟 DOM 中 key 的作用"></a>虚拟 DOM 中 key 的作用</h2><p>key 是虚拟 DOM 对象的标识，当数据发生变化时，Vue 会根据<code>新数据</code>生成<code>新的虚拟DOM</code>，随后 Vue 进行<code>新虚拟DOM</code>与<code>旧虚拟DOM</code>的差异比较，比较规则如下</p><h2 id="对比规则"><a href="#对比规则" class="headerlink" title="对比规则"></a>对比规则</h2><ol><li><p>旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：</p><ul><li><p>若虚拟 DOM 中内容没变，直接使用之前的真实 DOM！</p></li><li><p>若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</p></li></ul></li><li><p> 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key，创建新的真实 DOM，随后渲染到页面。</p></li></ol><h2 id="用-index-作为-key-可能引发的问题"><a href="#用-index-作为-key-可能引发的问题" class="headerlink" title="用 index 作为 key 可能引发的问题"></a>用 index 作为 key 可能引发的问题</h2><ul><li><p>若对数据进行逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实 DOM 更新 ==&gt; 界面效果没问题，但效率低</p></li><li><p>如果结构中还包含输入类的 DOM：会产生错误 DOM 更新 ==&gt; 界面有问题<br><img src="https://cdn.jsdelivr.net/gh/kincar/image@main/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220102213548.png" alt="添加前"><br><img src="https://cdn.jsdelivr.net/gh/kincar/image@main/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220102213727.png" alt="添加后"></p></li></ul><h2 id="开发中如何选择-key？"><a href="#开发中如何选择-key？" class="headerlink" title="开发中如何选择 key？"></a>开发中如何选择 key？</h2><ul><li><p>最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等<code>唯一值</code></p></li><li><p>如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表、用于展示，使用 index 作为 key 是没有问题的</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> key </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2021/12/29/markdawn%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/12/29/markdawn%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h1><h2 id="一、标题（常用）"><a href="#一、标题（常用）" class="headerlink" title="一、标题（常用）"></a>一、标题（常用）</h2><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p><blockquote><p>注意：标准语法一般在#后跟个空格再写文字。</p></blockquote><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 这是一级标题</span><span class="token comment" spellcheck="true">## 这是二级标题</span><span class="token comment" spellcheck="true">### 这是三级标题</span><span class="token comment" spellcheck="true">#### 这是四级标题</span><span class="token comment" spellcheck="true">##### 这是五级标题</span><span class="token comment" spellcheck="true">###### 这是六级标题</span></code></pre><p>效果如下：</p><h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><h2 id="二、字体（常用）"><a href="#二、字体（常用）" class="headerlink" title="二、字体（常用）"></a>二、字体（常用）</h2><ul><li><strong>加粗：</strong></li></ul><p>要加粗的文字左右分别用两个*号包起来</p><ul><li><em>斜体：</em></li></ul><p>要倾斜的文字左右分别用一个*号包起来</p><ul><li><strong><em>斜体加粗：</em></strong></li></ul><p>要倾斜和加粗的文字分别用三个*号包起来</p><ul><li><del>删除线：</del></li></ul><p>要加删除线的问女子左右分别用两个~~号包起来</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">**我是加粗的文字***我是倾斜的文字****我是斜体加粗的文字***~~我是加删除线的文字~~</code></pre><p>效果如下：</p><p><strong>我是加粗的文字</strong></p><p><em>我是倾斜的文字</em></p><p><strong><em>我是斜体加粗的文字</em></strong></p><p><del>我是加删除线的文字</del></p><h2 id="三、引用（常用）"><a href="#三、引用（常用）" class="headerlink" title="三、引用（常用）"></a>三、引用（常用）</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n 个…，<br>貌似可以一直加，但没神马卵用</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span> 一盏灯， 一片昏黄； 一简书， 一杯淡茶。<span class="token operator">>></span> 守着那一份淡定， 品读属于自己的寂寞。<span class="token operator">>></span><span class="token operator">></span>  保持淡定， 才能欣赏到最美丽的风景！<span class="token operator">>></span><span class="token operator">>></span> 保持淡定， 人生从此不再寂寞。</code></pre><p>效果如下：</p><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。</p><blockquote><p>守着那一份淡定， 品读属于自己的寂寞。</p><blockquote><p>保持淡定， 才能欣赏到最美丽的风景！</p><blockquote><p>保持淡定， 人生从此不再寂寞。</p></blockquote></blockquote></blockquote></blockquote><h2 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h2><p>三个或者三个以上的-或者*都可以</p><p>示例：</p><pre class=" language-bash"><code class="language-bash">-------*******</code></pre><p>效果如下：</p><hr><hr><hr><hr><h2 id="五、图片（常用）"><a href="#五、图片（常用）" class="headerlink" title="五、图片（常用）"></a>五、图片（常用）</h2><pre class=" language-bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>图片alt<span class="token punctuation">]</span><span class="token punctuation">(</span>图片地址 <span class="token string">"图片title"</span><span class="token punctuation">)</span></code></pre><p>图片 alt 就是显示在图片下面的文字，相当于对图片内容的解释<br>图片 title 是图片的标题，当鼠标移到图片上时显示的内容。title 可加可不加</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">!</span><span class="token punctuation">[</span>blockchain<span class="token punctuation">]</span><span class="token punctuation">(</span>https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u<span class="token operator">=</span>702257389,1274025419<span class="token operator">&amp;</span>fm<span class="token operator">=</span>27<span class="token operator">&amp;</span>gp<span class="token operator">=</span>0.jpg <span class="token string">"区块链"</span><span class="token punctuation">)</span></code></pre><p>效果如下：</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&fm=27&gp=0.jpg" alt="blockchain" title="区块链"></p><p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p><p>markdown 格式追求的是简单、多平台统一。name 图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。</p><p>关于图床的选择，可以看看这一篇文章：</p><p><a href="https://www.jianshu.com/p/ea1eb11db63f">markdown 图床</a></p><h2 id="六、超链接（常用）"><a href="#六、超链接（常用）" class="headerlink" title="六、超链接（常用）"></a>六、超链接（常用）</h2><p>语法：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>超链接<span class="token punctuation">]</span><span class="token punctuation">(</span>超链接地址 <span class="token string">"超链接title"</span><span class="token punctuation">)</span></code></pre><p>title 可加可不加</p><p>示例：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>简书<span class="token punctuation">]</span><span class="token punctuation">(</span>http://jianshu.com<span class="token punctuation">)</span><span class="token punctuation">[</span>百度<span class="token punctuation">]</span><span class="token punctuation">(</span>http://baidu.com<span class="token punctuation">)</span></code></pre><p>效果如下：</p><p><a href="http://jianshu.com/">简书</a></p><p><a href="http://baidu.com/">百度</a></p><blockquote><p>注意：Markdown 本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用 html 语言的 a 标签代替</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"超链接地址"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span><span class="token operator">></span>超链接名<span class="token operator">&lt;</span>/a<span class="token operator">></span>示例：<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span><span class="token operator">></span>简书<span class="token operator">&lt;</span>/a<span class="token operator">></span></code></pre><p>效果如下：<br><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank">简书</a></p><h2 id="七、列表（常用）"><a href="#七、列表（常用）" class="headerlink" title="七、列表（常用）"></a>七、列表（常用）</h2><p><strong>无序列表</strong></p><p>语法：</p><p>无序列表用 - + * 任何一种都可以</p><pre class=" language-bash"><code class="language-bash">    - 列表内容    + 类表内容    * 列表内容</code></pre><blockquote><p>注意：-+*跟内容之间都要有一个空格</p></blockquote><p>效果如下：</p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><p><strong>有序列表</strong></p><p>语法：</p><p>数字加点</p><pre class=" language-bash"><code class="language-bash">    1. 列表内容    2. 列表内容    3. 列表内容</code></pre><blockquote><p>注意：序号跟内容之间要有空格</p></blockquote><p>效果如下：</p><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><p><strong>列表嵌套</strong></p><p>上一级和下一级之间敲三个空格即可</p><ul><li><p>一级无序列表</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级无序列表</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ul><ol><li><p>一级有序列表</p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li><li><p>一级有序列表</p><ol><li>二级有序列表内容</li><li>二级有序列表内容</li><li>二级有序列表内容</li></ol></li></ol><h2 id="八、表格（常用）"><a href="#八、表格（常用）" class="headerlink" title="八、表格（常用）"></a>八、表格（常用）</h2><p>语法：</p><pre class=" language-bash"><code class="language-bash">表头<span class="token operator">|</span>表头<span class="token operator">|</span>表头---<span class="token operator">|</span>:---:<span class="token operator">|</span>---:内容<span class="token operator">|</span>内容<span class="token operator">|</span>内容内容<span class="token operator">|</span>内容<span class="token operator">|</span>内容</code></pre><p>第二行分割表头和内容<br>有一个就行，为了对齐，多加了几个<br>文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右</p><blockquote><p>注意：原生的语法两边都要用|包起来。此处省略</p></blockquote><p>示例：</p><pre class=" language-bash"><code class="language-bash">    姓名<span class="token operator">|</span>技能<span class="token operator">|</span>排行    --<span class="token operator">|</span>:--:<span class="token operator">|</span>--:    刘备<span class="token operator">|</span>哭<span class="token operator">|</span>大哥    关羽<span class="token operator">|</span>打<span class="token operator">|</span>二哥    张飞<span class="token operator">|</span>骂<span class="token operator">|</span>三弟</code></pre><p>效果如下：</p><table><thead><tr><th>姓名</th><th align="center">技能</th><th align="right">排行</th></tr></thead><tbody><tr><td>刘备</td><td align="center">哭</td><td align="right">大哥</td></tr><tr><td>关羽</td><td align="center">打</td><td align="right">二哥</td></tr><tr><td>张飞</td><td align="center">骂</td><td align="right">三弟</td></tr></tbody></table><h2 id="九、代码（常用）"><a href="#九、代码（常用）" class="headerlink" title="九、代码（常用）"></a>九、代码（常用）</h2><p>语法：</p><p>单行代码（只有一段，不分行）：代码之间分别用一个反引号`包起来</p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>代码内容<span class="token variable">`</span></span></code></pre><p>代码块（多行）：代码之间分别用三个反引号```包起来，并且两边的反引号单独占一行</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>``<span class="token variable"><span class="token variable">`</span><span class="token punctuation">)</span>    代码<span class="token punctuation">..</span>.    代码<span class="token punctuation">..</span>.    代码<span class="token punctuation">..</span>.<span class="token punctuation">(</span><span class="token variable">`</span></span>``<span class="token punctuation">)</span></code></pre><blockquote><p>注意：为了防止转义，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可</p></blockquote><p>示例：</p><p>单行代码</p><pre class=" language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">`</span>create Vue Demo<span class="token variable">`</span></span></code></pre><p>代码块</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">(</span>```<span class="token punctuation">)</span>    <span class="token keyword">function</span> fun<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">echo</span> <span class="token string">'这是一段牛逼的代码'</span>    <span class="token punctuation">}</span>    fun<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>```<span class="token punctuation">)</span></code></pre><p>效果如下：</p><p>单行代码</p><p><code>create Vue Demo</code></p><p>代码块</p><pre class=" language-bash"><code class="language-bash"><span class="token keyword">function</span> fun<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">echo</span> <span class="token string">'这是一段牛逼的代码'</span><span class="token punctuation">}</span>fun<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo基本用法</title>
      <link href="/2021/12/28/hello-world/"/>
      <url>/2021/12/28/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>欢迎光临[Hexo] (<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a>) ! 这是你的第一篇文章。 查看<a href="https://hexo.io/zh-cn/docs/">文档</a>获取更多信息。 如果你在使用 Hexo 时遇到任何问题，你可以在<a href="https://hexo.io/zh-cn/docs/troubleshooting.html">故障排除</a>中找到答案，或者你可以在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上问我。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="hexo-new"><a href="#hexo-new" class="headerlink" title="hexo new"></a>hexo new</h3><blockquote><p>新建一篇文章</p></blockquote><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><blockquote><p>文章标题可以在对应 md 文件里改，新建时标题可以写的简单写</p></blockquote><p>More info: <a href="https://hexo.io/zh-cn/docs/writing.html">Writing</a></p><h3 id="hexo-s"><a href="#hexo-s" class="headerlink" title="hexo s"></a>hexo s</h3><blockquote><p>启动服务器，用于预览主题，默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p></blockquote><blockquote><p>预览的同时可以修改文章内容或主题代码，保存后刷新页面即可</p></blockquote><blockquote><p>对 Hexo 根目录_config.yml 的修改，需要重启本地服务器才能预览效果</p></blockquote><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>-p 重设端口</p><p>More info: <a href="https://hexo.io/zh-cn/docs/server.html">Server</a></p><h3 id="hexo-g"><a href="#hexo-g" class="headerlink" title="hexo g"></a>hexo g</h3><blockquote><p>生成静态文件到默认设置的 public 文件</p></blockquote><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>-d 文件生成后立即部署网站<br>-w 监视文件变动</p><p>More info: <a href="https://hexo.io/zh-cn/docs/generating.html">Generating</a></p><h3 id="hexo-d"><a href="#hexo-d" class="headerlink" title="hexo d"></a>hexo d</h3><blockquote><p>自动生成网站静态文件，并部署到设定的仓库</p></blockquote><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>-g 部署之前预先生成静态文件</p><p>More info: <a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">Deployment</a></p><h3 id="hexo-cl"><a href="#hexo-cl" class="headerlink" title="hexo cl"></a>hexo cl</h3><blockquote><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)</p></blockquote><blockquote><p>网站显示异常时可以执行这条命令试试</p></blockquote><pre class=" language-bash"><code class="language-bash">$ hexo clean</code></pre><h3 id="hexo-new-page"><a href="#hexo-new-page" class="headerlink" title="hexo new page"></a>hexo new page</h3><pre class=" language-bash"><code class="language-bash">hexo new page xxx</code></pre><blockquote><p>新建一个标题为 xxx 的页面，默认链接地址为主页地址/xxx/</p></blockquote><blockquote><p>标题可以为中文，但一般习惯用英文</p></blockquote><blockquote><p>页面标题和文章一样可以随意修改</p></blockquote><blockquote><p>页面不会出现在首页文章列表和归档中，也不支持设置分类和标签</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
